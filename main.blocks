<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="K9FU]=J;Cy(y%$I|9VI9" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="s@%w*;}i~B[V8B^H{K6G"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace aiPonybot {" line1="    /**" line2="     * ---------------PCA9685-------------------" line3="     */" line4="    const PCA9685_ADDRESS = 0x40;" line5="    const MODE1 = 0x00;" line6="    const MODE2 = 0x01;" line7="    const SUBADR1 = 0x02;" line8="    const SUBADR2 = 0x03;" line9="    const SUBADR3 = 0x04;" line10="    const PRESCALE = 0xFE;" line11="    const LED0_ON_L = 0x06;" line12="    const LED0_ON_H = 0x07;" line13="    const LED0_OFF_L = 0x08;" line14="    const LED0_OFF_H = 0x09;" line15="    const ALL_LED_ON_L = 0xFA;" line16="    const ALL_LED_ON_H = 0xFB;" line17="    const ALL_LED_OFF_L = 0xFC;" line18="    const ALL_LED_OFF_H = 0xFD;" line19="" line20="    const STP_CHA_L = 2047;" line21="    const STP_CHA_H = 4095;" line22="    const STP_CHB_L = 1;" line23="    const STP_CHB_H = 2047;" line24="    const STP_CHC_L = 1023;" line25="    const STP_CHC_H = 3071;" line26="    const STP_CHD_L = 3071;" line27="    const STP_CHD_H = 1023;" line28="" line29="    const BYG_CHA_L = 3071;" line30="    const BYG_CHA_H = 1023;" line31="    const BYG_CHB_L = 1023;" line32="    const BYG_CHB_H = 3071;" line33="    const BYG_CHC_L = 4095;" line34="    const BYG_CHC_H = 2047;" line35="    const BYG_CHD_L = 2047;" line36="    const BYG_CHD_H = 4095;" line37="" line38="    export enum Mecanum {" line39="        //% block=&quot;↖&quot;" line40="        LeftForward = 1," line41="        //% block=&quot;↑&quot;" line42="        Forward = 2," line43="        //% block=&quot;↗&quot;" line44="        RightForward = 3," line45="        //% block=&quot;←&quot;" line46="        Left = 4," line47="        //% block=&quot;s&quot;" line48="        Stop = 5," line49="        //% block=&quot;→&quot;" line50="        Right = 6," line51="        //% block=&quot;↙&quot;" line52="        LeftBackward = 7," line53="        //% block=&quot;↓&quot;" line54="        Backward = 8," line55="        //% block=&quot;↘&quot;" line56="        RightBackward = 9" line57="    }" line58="" line59="    export enum DirectionControl {" line60="        //% block=&quot;↑&quot;" line61="        Forward = 1," line62="        //% block=&quot;↓&quot;" line63="        Backward = 2," line64="        //% block=&quot;↶&quot;" line65="        Clockwise = 3," line66="        //% block=&quot;↷&quot;" line67="        CounterClockwise = 4," line68="    }" line69="" line70="    export enum Stepper {" line71="        //% block=&quot;42&quot;" line72="        Stepper42 = 1," line73="        //% block=&quot;28&quot;" line74="        Stepper28 = 2" line75="    }" line76="" line77="    export enum Servo {" line78="        //% block=&quot;서보 1&quot;" line79="        Servo1 = 0x01," line80="        //% block=&quot;서보 2&quot;" line81="        Servo2 = 0x02," line82="        //% block=&quot;서보 3&quot;" line83="        Servo3 = 0x03," line84="        //% block=&quot;서보 4&quot;" line85="        Servo4 = 0x04," line86="        //% block=&quot;서보 5&quot;" line87="        Servo5 = 0x05," line88="        //% block=&quot;서보 6&quot;" line89="        Servo6 = 0x06," line90="        //% block=&quot;서보 7&quot;" line91="        Servo7 = 0x07," line92="        //% block=&quot;서보 8&quot;" line93="        Servo8 = 0x08" line94="    }" line95="" line96="    export enum Motor {" line97="        //% block=&quot;모터 1&quot;" line98="        Motor1 = 0x1," line99="        //% block=&quot;모터 2&quot;" line100="        Motor2 = 0x2," line101="        //% block=&quot;모터 3&quot;" line102="        Motor3 = 0x3," line103="        //% block=&quot;모터 4&quot;" line104="        Motor4 = 0x4" line105="    }" line106="" line107="    export enum Direction {" line108="        //% blockId=&quot;정회전&quot; block=&quot;정회전&quot;" line109="        Clockwise = 1," line110="        //% blockId=&quot;역회전&quot; block=&quot;역회전&quot;" line111="        CounterClockwise = -1," line112="    }" line113="" line114="    export enum StepperPair {" line115="        Motors1And2 = 0x1," line116="        Motors3And4 = 0x2" line117="    }" line118="" line119="    let initialized = false;" line120="" line121="    function i2cWrite(address: number, register: number, value: number) {" line122="        let buffer = pins.createBuffer(2);" line123="        buffer[0] = register;" line124="        buffer[1] = value;" line125="        pins.i2cWriteBuffer(address, buffer);" line126="    }" line127="" line128="    function i2cCmd(address: number, value: number) {" line129="        let buffer2 = pins.createBuffer(1);" line130="        buffer2[0] = value;" line131="        pins.i2cWriteBuffer(address, buffer2);" line132="    }" line133="" line134="    function i2cRead(address: number, register: number) {" line135="        pins.i2cWriteNumber(address, register, NumberFormat.UInt8BE);" line136="        let value = pins.i2cReadNumber(address, NumberFormat.UInt8BE);" line137="        return value;" line138="    }" line139="" line140="    function initPCA9685(): void {" line141="        i2cWrite(PCA9685_ADDRESS, MODE1, 0x00);" line142="        setFreq(50);" line143="        initialized = true;" line144="    }" line145="" line146="    function setFreq(frequency: number): void {" line147="        let prescaleValue = 25000000;" line148="        prescaleValue /= 4096;" line149="        prescaleValue /= frequency;" line150="        prescaleValue -= 1;" line151="        let prescale = prescaleValue;" line152="        let oldMode = i2cRead(PCA9685_ADDRESS, MODE1);" line153="        let newMode = (oldMode &amp; 0x7F) | 0x10; // sleep" line154="        i2cWrite(PCA9685_ADDRESS, MODE1, newMode); // go to sleep" line155="        i2cWrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler" line156="        i2cWrite(PCA9685_ADDRESS, MODE1, oldMode);" line157="        control.waitMicros(5000);" line158="        i2cWrite(PCA9685_ADDRESS, MODE1, oldMode | 0xa1);" line159="    }" line160="" line161="    function setPwm(channel: number, on: number, off: number): void {" line162="        if (channel &lt; 0 || channel &gt; 15) return;" line163="" line164="        let buffer3 = pins.createBuffer(5);" line165="        buffer3[0] = LED0_ON_L + 4 * channel;" line166="        buffer3[1] = on &amp; 0xff;" line167="        buffer3[2] = (on &gt;&gt; 8) &amp; 0xff;" line168="        buffer3[3] = off &amp; 0xff;" line169="        buffer3[4] = (off &gt;&gt; 8) &amp; 0xff;" line170="        pins.i2cWriteBuffer(PCA9685_ADDRESS, buffer3);" line171="    }" line172="" line173="    function setStepper28(index: number, direction: boolean): void {" line174="        if (index == 1) {" line175="            if (direction) {" line176="                setPwm(4, STP_CHA_L, STP_CHA_H);" line177="                setPwm(6, STP_CHB_L, STP_CHB_H);" line178="                setPwm(5, STP_CHC_L, STP_CHC_H);" line179="                setPwm(7, STP_CHD_L, STP_CHD_H);" line180="            } else {" line181="                setPwm(7, STP_CHA_L, STP_CHA_H);" line182="                setPwm(5, STP_CHB_L, STP_CHB_H);" line183="                setPwm(6, STP_CHC_L, STP_CHC_H);" line184="                setPwm(4, STP_CHD_L, STP_CHD_H);" line185="            }" line186="        } else {" line187="            if (direction) {" line188="                setPwm(0, STP_CHA_L, STP_CHA_H);" line189="                setPwm(2, STP_CHB_L, STP_CHB_H);" line190="                setPwm(1, STP_CHC_L, STP_CHC_H);" line191="                setPwm(3, STP_CHD_L, STP_CHD_H);" line192="            } else {" line193="                setPwm(3, STP_CHA_L, STP_CHA_H);" line194="                setPwm(1, STP_CHB_L, STP_CHB_H);" line195="                setPwm(2, STP_CHC_L, STP_CHC_H);" line196="                setPwm(0, STP_CHD_L, STP_CHD_H);" line197="            }" line198="        }" line199="    }" line200="" line201="    function setStepper42(index: number, direction: boolean): void {" line202="        if (index == 1) {" line203="            if (direction) {" line204="                setPwm(7, BYG_CHA_L, BYG_CHA_H);" line205="                setPwm(6, BYG_CHB_L, BYG_CHB_H);" line206="                setPwm(5, BYG_CHC_L, BYG_CHC_H);" line207="                setPwm(4, BYG_CHD_L, BYG_CHD_H);" line208="            } else {" line209="                setPwm(7, BYG_CHC_L, BYG_CHC_H);" line210="                setPwm(6, BYG_CHD_L, BYG_CHD_H);" line211="                setPwm(5, BYG_CHA_L, BYG_CHA_H);" line212="                setPwm(4, BYG_CHB_L, BYG_CHB_H);" line213="            }" line214="        } else {" line215="            if (direction) {" line216="                setPwm(3, BYG_CHA_L, BYG_CHA_H);" line217="                setPwm(2, BYG_CHB_L, BYG_CHB_H);" line218="                setPwm(1, BYG_CHC_L, BYG_CHC_H);" line219="                setPwm(0, BYG_CHD_L, BYG_CHD_H);" line220="            } else {" line221="                setPwm(3, BYG_CHC_L, BYG_CHC_H);" line222="                setPwm(2, BYG_CHD_L, BYG_CHD_H);" line223="                setPwm(1, BYG_CHA_L, BYG_CHA_H);" line224="                setPwm(0, BYG_CHB_L, BYG_CHB_H);" line225="            }" line226="        }" line227="    }" line228="" line229="    //% blockId=aiponybot_motor_servo block=&quot;|%index|서보모터|%degree|각도로 이동&quot;" line230="    //% weight=0" line231="    //% degree.min=0 degree.max=180" line232="    //% index.fieldEditor=&quot;gridpicker&quot; index.fieldOptions.columns=4" line233="    //% group=&quot;서보모터 제어&quot;" line234="    export function servo(index: Servo, degree: number): void {" line235="        if (!initialized) {" line236="            initPCA9685();" line237="        }" line238="        let microseconds = (degree * 1800 / 180 + 600); // 0.6ms ~ 2.4ms" line239="        let value2 = microseconds * 4096 / 20000;" line240="        setPwm(index + 7, 0, value2);" line241="    }" line242="" line243="    //% weight=0" line244="    //% blockId=aiponybot_motor_runMotor block=&quot;|%index|모터|%direction|방향|%speed|속도로 회전&quot;" line245="    //% speed.min=0 speed.max=255" line246="    //% index.fieldEditor=&quot;gridpicker&quot; index.fieldOptions.columns=2" line247="    //% direction.fieldEditor=&quot;gridpicker&quot; direction.fieldOptions.columns=2" line248="    //% group=&quot;모터 제어(심화)&quot;" line249="    export function runMotor(index: Motor, direction: Direction, speed: number): void {" line250="        if (!initialized) {" line251="            initPCA9685();" line252="        }" line253="        if (index === Motor.Motor3 || index === Motor.Motor4) {" line254="            direction = direction * -1 as Direction;" line255="        }" line256="        speed = speed * 16 * direction; // map 255 to 4096" line257="        if (speed &gt;= 4096) speed = 4095;" line258="        if (speed &lt;= -4096) speed = -4095;" line259="        if (index &gt; 4 || index &lt;= 0) return;" line260="        let positivePin = (4 - index) * 2;" line261="        let negativePin = (4 - index) * 2 + 1;" line262="        if (speed &gt;= 0) {" line263="            setPwm(positivePin, 0, 0);" line264="            setPwm(negativePin, 0, speed);" line265="        } else {" line266="            setPwm(positivePin, 0, -speed);" line267="            setPwm(negativePin, 0, -0);" line268="        }" line269="    }" line270="" line271="    //% weight=0" line272="    //% blockId=aiponybot_motor_runMecanum block=&quot;|메카넘|%direction|방향|%speed|속도로 이동&quot;" line273="    //% speed.min=0 speed.max=255" line274="    //% direction.fieldEditor=&quot;gridpicker&quot; direction.fieldOptions.columns=3" line275="    //% group=&quot;모터 제어(기초)&quot;" line276="    export function runMecanum(direction: Mecanum, speed: number): void {" line277="        if (!initialized) {" line278="            initPCA9685();" line279="        }" line280="        speed = speed * 16; // map 255 to 4096" line281="        if (speed &gt;= 4096) speed = 4095;" line282="        if (speed &lt;= -4096) speed = -4095;" line283="" line284="        switch (direction) {" line285="            case Mecanum.LeftForward: // ↖" line286="                setPwm(7, 0, speed); setPwm(6, 0, 0); // M1 forward" line287="                setPwm(5, 0, 0); setPwm(4, 0, 0); // M2 stop" line288="                setPwm(3, 0, 0); setPwm(2, 0, speed); // M3 forward" line289="                setPwm(1, 0, 0); setPwm(0, 0, 0); // M4 stop" line290="                break;" line291="            case Mecanum.Forward: // ↑" line292="                setPwm(7, 0, speed); setPwm(6, 0, 0); // M1 forward" line293="                setPwm(5, 0, speed); setPwm(4, 0, 0); // M2 forward" line294="                setPwm(3, 0, 0); setPwm(2, 0, speed); // M3 forward" line295="                setPwm(1, 0, 0); setPwm(0, 0, speed); // M4 forward" line296="                break;" line297="            case Mecanum.RightForward: // ↗" line298="                setPwm(7, 0, 0); setPwm(6, 0, 0); // M1 stop" line299="                setPwm(5, 0, speed); setPwm(4, 0, 0); // M2 forward" line300="                setPwm(3, 0, 0); setPwm(2, 0, 0); // M3 stop" line301="                setPwm(1, 0, 0); setPwm(0, 0, speed); // M4 forward" line302="                break;" line303="            case Mecanum.Left: // ←" line304="                setPwm(7, 0, speed); setPwm(6, 0, 0); // M1 forward" line305="                setPwm(5, 0, 0); setPwm(4, 0, speed); // M2 backward" line306="                setPwm(3, 0, 0); setPwm(2, 0, speed); // M3 forward" line307="                setPwm(1, 0, speed); setPwm(0, 0, 0); // M4 backward" line308="                break;" line309="            case Mecanum.Stop: // s" line310="                setPwm(7, 0, 0); setPwm(6, 0, 0); // M1 stop" line311="                setPwm(5, 0, 0); setPwm(4, 0, 0); // M2 stop" line312="                setPwm(3, 0, 0); setPwm(2, 0, 0); // M3 stop" line313="                setPwm(1, 0, 0); setPwm(0, 0, 0); // M4 stop" line314="                break;" line315="            case Mecanum.Right: // →" line316="                setPwm(7, 0, 0); setPwm(6, 0, speed); // M1 backward" line317="                setPwm(5, 0, speed); setPwm(4, 0, 0); // M2 forward" line318="                setPwm(3, 0, speed); setPwm(2, 0, 0); // M3 backward" line319="                setPwm(1, 0, 0); setPwm(0, 0, speed); // M4 forward" line320="                break;" line321="            case Mecanum.LeftBackward: // ↙" line322="                setPwm(7, 0, 0); setPwm(6, 0, 0); // M1 stop" line323="                setPwm(5, 0, 0); setPwm(4, 0, speed); // M2 backward" line324="                setPwm(3, 0, 0); setPwm(2, 0, 0); // M3 stop" line325="                setPwm(1, 0, speed); setPwm(0, 0, 0); // M4 backward" line326="                break;" line327="            case Mecanum.Backward: // ↓" line328="                setPwm(7, 0, 0); setPwm(6, 0, speed); // M1 backward" line329="                setPwm(5, 0, 0); setPwm(4, 0, speed); // M2 backward" line330="                setPwm(3, 0, speed); setPwm(2, 0, 0); // M3 backward" line331="                setPwm(1, 0, speed); setPwm(0, 0, 0); // M4 backward" line332="                break;" line333="            case Mecanum.RightBackward: // ↘" line334="                setPwm(7, 0, 0); setPwm(6, 0, speed); // M1 backward" line335="                setPwm(5, 0, 0); setPwm(4, 0, 0); // M2 stop" line336="                setPwm(3, 0, speed); setPwm(2, 0, 0); // M3 backward" line337="                setPwm(1, 0, 0); setPwm(0, 0, 0); // M4 stop" line338="                break;" line339="        }" line340="    }" line341="" line342="    //% weight=0" line343="    //% blockId=aiponybot_motor_stopMotor block=&quot;|%index|모터 정지&quot;" line344="    //% index.fieldEditor=&quot;gridpicker&quot; index.fieldOptions.columns=2 " line345="    //% group=&quot;모터 제어(심화)&quot;" line346="    export function stopMotor(index: Motor) {" line347="        setPwm((4 - index) * 2, 0, 0);" line348="        setPwm((4 - index) * 2 + 1, 0, 0);" line349="    }" line350="" line351="    //% weight=20" line352="    //% blockId=aiponybot_motor_stopAllMotors block=&quot;|모든 모터 정지&quot;" line353="    //% group=&quot;모터 제어(기초)&quot;" line354="    export function stopAllMotors(): void {" line355="        for (let idx = 1; idx &lt;= 4; idx++) {" line356="            stopMotor(idx as Motor);" line357="        }" line358="    }" line359="" line360="    //% weight=0" line361="    //% blockId=aiponybot_motor_runNormal block=&quot;|포니봇|%direction|방향|%speed|속도로 이동&quot;" line362="    //% speed.min=0 speed.max=255" line363="    //% direction.fieldEditor=&quot;gridpicker&quot; direction.fieldOptions.columns=2" line364="    //% group=&quot;모터 제어(기초)&quot;" line365="    export function runNormal(direction: DirectionControl, speed: number): void {" line366="        if (!initialized) {" line367="            initPCA9685();" line368="        }" line369="        speed = speed * 16; // map 255 to 4096" line370="        if (speed &gt;= 4096) speed = 4095;" line371="        if (speed &lt;= -4096) speed = -4095;" line372="" line373="        switch (direction) {" line374="            case DirectionControl.Forward: // ↑" line375="                setPwm(7, 0, speed); setPwm(6, 0, 0); // M1 forward" line376="                setPwm(5, 0, speed); setPwm(4, 0, 0); // M2 forward" line377="                setPwm(3, 0, 0); setPwm(2, 0, speed); // M3 forward" line378="                setPwm(1, 0, 0); setPwm(0, 0, speed); // M4 forward" line379="                break;" line380="            case DirectionControl.Backward: // ↓" line381="                setPwm(7, 0, 0); setPwm(6, 0, speed); // M1 backward" line382="                setPwm(5, 0, 0); setPwm(4, 0, speed); // M2 backward" line383="                setPwm(3, 0, speed); setPwm(2, 0, 0); // M3 backward" line384="                setPwm(1, 0, speed); setPwm(0, 0, 0); // M4 backward" line385="                break;" line386="            case DirectionControl.Clockwise: // ↶" line387="                setPwm(7, 0, speed); setPwm(6, 0, 0); // M1 forward" line388="                setPwm(5, 0, speed); setPwm(4, 0, 0); // M2 forward" line389="                setPwm(3, 0, speed); setPwm(2, 0, 0); // M3 backward" line390="                setPwm(1, 0, speed); setPwm(0, 0, 0); // M4 backward" line391="                break;" line392="            case DirectionControl.CounterClockwise: // ↷" line393="                setPwm(7, 0, 0); setPwm(6, 0, speed); // M1 backward" line394="                setPwm(5, 0, 0); setPwm(4, 0, speed); // M2 backward" line395="                setPwm(3, 0, 0); setPwm(2, 0, speed); // M3 forward" line396="                setPwm(1, 0, 0); setPwm(0, 0, speed); // M4 forward" line397="                break;" line398="        }" line399="    }" line400="" line401="    /**" line402="     * ---------------line sensor-------------------" line403="     */" line404="    export enum TwoLineState {" line405="        //% block=&quot;◌ ◌ &quot; " line406="        OffOff = 0," line407="        //% block=&quot;● ●&quot; " line408="        OnOn = 1," line409="        //% block=&quot;● ◌&quot; " line410="        OnOff = 2," line411="        //% block=&quot;◌ ●&quot; " line412="        OffOn = 3," line413="    }" line414="" line415="    export enum LineState {" line416="        //% block=&quot;◌&quot; " line417="        Off = 0," line418="        //% block=&quot;●&quot; " line419="        On = 1" line420="    }" line421="" line422="    export enum LineSensorChannel {" line423="        //% block=&quot;왼쪽&quot;" line424="        Left = 1," line425="        //% block=&quot;오른쪽&quot;" line426="        Right = 2," line427="    }" line428="" line429="    //% blockId=&quot;checkTwoLineState&quot;" line430="    //% block=&quot;두 라인 센서의 값이 %state&quot;" line431="    //% state.fieldEditor=&quot;gridpicker&quot; state.fieldOptions.columns=2" line432="    //% group=&quot;라인 감지 센서&quot;" line433="    //% weight=0" line434="    export function checkTwoLineState(state: TwoLineState): boolean {" line435="        const leftSensor = pins.digitalReadPin(DigitalPin.P16);" line436="        const rightSensor = pins.digitalReadPin(DigitalPin.P15);" line437="" line438="        switch (state) {" line439="            case TwoLineState.OffOff:" line440="                return leftSensor === 0 &amp;&amp; rightSensor === 0;" line441="            case TwoLineState.OnOn:" line442="                return leftSensor === 1 &amp;&amp; rightSensor === 1;" line443="            case TwoLineState.OnOff:" line444="                return leftSensor === 1 &amp;&amp; rightSensor === 0;" line445="            case TwoLineState.OffOn:" line446="                return leftSensor === 0 &amp;&amp; rightSensor === 1;" line447="            default:" line448="                return false;" line449="        }" line450="    }" line451="" line452="    //% blockId=&quot;checkSingleLineSensor&quot;" line453="    //% block=&quot;%channel 라인 센서의 값이 %state&quot;" line454="    //% channel.fieldEditor=&quot;gridpicker&quot; channel.fieldOptions.columns=2" line455="    //% state.fieldEditor=&quot;gridpicker&quot; state.fieldOptions.columns=2" line456="    //% group=&quot;라인 감지 센서&quot;" line457="    //% weight=0" line458="    export function checkSingleLineSensor(channel: LineSensorChannel, state: LineState): boolean {" line459="        const sensorValue = channel === LineSensorChannel.Left" line460="            ? pins.digitalReadPin(DigitalPin.P16)" line461="            : pins.digitalReadPin(DigitalPin.P15);" line462="        return sensorValue === state;" line463="    }" line464="" line465="    //% blockId=&quot;readLineSensor&quot;" line466="    //% block=&quot;%channel 라인 센서 값 읽기&quot;" line467="    //% channel.fieldEditor=&quot;gridpicker&quot; channel.fieldOptions.columns=2" line468="    //% group=&quot;라인 감지 센서&quot;" line469="    //% weight=0" line470="    export function readLineSensor(channel: LineSensorChannel): number {" line471="        return channel === LineSensorChannel.Left" line472="            ? pins.digitalReadPin(DigitalPin.P16)" line473="            : pins.digitalReadPin(DigitalPin.P15);" line474="    }" line475="" line476="    /**" line477="     * ---------------sonar sensor-------------------" line478="     */" line479="    export enum PingUnit {" line480="        //% block=&quot;마이크로초&quot;" line481="        MicroSeconds," line482="        //% block=&quot;센티미터&quot;" line483="        Centimeters," line484="        //% block=&quot;인치&quot;" line485="        Inches" line486="    }" line487="" line488="    //% blockId=aiponybot_sonar_ping" line489="    //% block=&quot;%unit 단위로 측정한 거리&quot;" line490="    //% unit.fieldEditor=&quot;gridpicker&quot; unit.fieldOptions.columns=2" line491="    //% group=&quot;거리 감지 센서&quot;" line492="    //% weight=0" line493="    export function ping(unit: PingUnit, maxCmDistance = 500): number {" line494="        const trigger = DigitalPin.P13; // Trig 핀 기본값" line495="        const echo = DigitalPin.P14; // Echo 핀 기본값" line496="        pins.setPull(trigger, PinPullMode.PullNone);" line497="        pins.digitalWritePin(trigger, 0);" line498="        control.waitMicros(2);" line499="        pins.digitalWritePin(trigger, 1);" line500="        control.waitMicros(10);" line501="        pins.digitalWritePin(trigger, 0);" line502="" line503="        const distance = pins.pulseIn(echo, PulseValue.High, maxCmDistance * 58);" line504="" line505="        if (distance === 0) {" line506="            switch (unit) {" line507="                case PingUnit.Centimeters: return maxCmDistance;" line508="                case PingUnit.Inches: return Math.idiv(maxCmDistance * 100, 254);" line509="                default: return maxCmDistance * 58;" line510="            }" line511="        }" line512="" line513="        switch (unit) {" line514="            case PingUnit.Centimeters: return Math.idiv(distance, 58);" line515="            case PingUnit.Inches: return Math.idiv(distance, 148);" line516="            default: return distance;" line517="        }" line518="    }" line519="" line520="    /**" line521="     * ---------------color sensor-------------------" line522="     */" line523="    export enum DetectedColor {" line524="        //% block=&quot;빨간색&quot;" line525="        Red," line526="        //% block=&quot;초록색&quot;" line527="        Green," line528="        //% block=&quot;파란색&quot;" line529="        Blue," line530="        //% block=&quot;노란색&quot;" line531="        Yellow" line532="    }" line533="" line534="    class Tcs3472 {" line535="        isSetup: boolean;" line536="        address: number;" line537="        leds: DigitalPin;" line538="" line539="        constructor(address: number) {" line540="            this.isSetup = false;" line541="            this.address = address;" line542="        }" line543="" line544="        setup(): void {" line545="            if (this.isSetup) return;" line546="            this.isSetup = true;" line547="            aiPonybot.smbus.writeByte(this.address, 0x80, 0x03); // Enable register: PON | AEN" line548="            aiPonybot.smbus.writeByte(this.address, 0x81, 0x2b); // Integration time: 103.2ms" line549="        }" line550="" line551="        setIntegrationTime(time: number): void {" line552="            this.setup();" line553="            time = Math.clamp(0, 255, time * 10 / 24);" line554="            aiPonybot.smbus.writeByte(this.address, 0x81, 255 - time);" line555="        }" line556="" line557="        light(): number {" line558="            return this.raw()[0]; // Clear channel 값 반환" line559="        }" line560="" line561="        rgb(): number[] {" line562="            let result: number[] = this.raw();" line563="            let clear: number = result.shift(); // Clear 값을 제거하고 저장" line564="            if (clear === 0) return [0, 0, 0]; // Clear가 0이면 기본값 반환" line565="            for (let index: number = 0; index &lt; result.length; index++) {" line566="                result[index] = result[index] * 255 / clear; // RGB 값을 Clear로 정규화" line567="            }" line568="            return result; // [R, G, B]" line569="        }" line570="" line571="        raw(): number[] {" line572="            this.setup();" line573="            try {" line574="                let result2: Buffer = aiPonybot.smbus.readBuffer(this.address, 0xb4, pins.sizeOf(NumberFormat.UInt16LE) * 4);" line575="                return aiPonybot.smbus.unpack(&quot;HHHH&quot;, result2); // [Clear, R, G, B]" line576="            } catch (e) {" line577="                return [0, 0, 0, 0]; // I2C 오류 시 기본값 반환" line578="            }" line579="        }" line580="    }" line581="" line582="    let colorSensor: Tcs3472 = new Tcs3472(0x29); // 기본 I2C 주소 0x29" line583="" line584="    //% blockId=aiponybot_color_tcs34725_get_light" line585="    //% block=&quot;밝기(B) 값 읽기&quot;" line586="    //% group=&quot;색상 감지 센서&quot;" line587="    export function getLight(): number {" line588="        return Math.round(colorSensor.light());" line589="    }" line590="" line591="    //% blockId=aiponybot_color_tcs34725_get_red" line592="    //% block=&quot;빨간색(R) 색상 값 읽기&quot;" line593="    //% group=&quot;색상 감지 센서&quot;" line594="    export function getRed(): number {" line595="        return Math.round(colorSensor.rgb()[0]);" line596="    }" line597="" line598="    //% blockId=aiponybot_color_tcs34725_get_green" line599="    //% block=&quot;초록색(G) 색상 값 읽기&quot;" line600="    //% group=&quot;색상 감지 센서&quot;" line601="    export function getGreen(): number {" line602="        return Math.round(colorSensor.rgb()[1]);" line603="    }" line604="" line605="    //% blockId=aiponybot_color_tcs34725_get_blue" line606="    //% block=&quot;파란색(B) 색상 값 읽기&quot;" line607="    //% group=&quot;색상 감지 센서&quot;" line608="    export function getBlue(): number {" line609="        return Math.round(colorSensor.rgb()[2]);" line610="    }" line611="" line612="    //% blockId=aiponybot_color_tcs34725_set_integration_time" line613="    //% block=&quot;색상 통합 시간을 %time ms로 설정&quot;" line614="    //% time.min=0 time.max=612 value.defl=500" line615="    //% group=&quot;색상 감지 센서&quot;" line616="    export function setColorIntegrationTime(time: number): void {" line617="        return colorSensor.setIntegrationTime(time);" line618="    }" line619="" line620="    //% blockId=aiponybot_color_sensor_is_color_advanced" line621="    //% block=&quot;감지된 색상이 %color (임계값 %threshold)&quot;" line622="    //% threshold.min=10 threshold.max=100 threshold.defl=40" line623="    //% group=&quot;색상 감지 센서&quot;" line624="    export function isColorAdvanced(color: DetectedColor, threshold: number = 40): boolean {" line625="        const rgb = colorSensor.rgb();" line626="        const red = rgb[0];" line627="        const green = rgb[1];" line628="        const blue = rgb[2];" line629="        const clear2 = colorSensor.light();" line630="" line631="        if (clear2 &lt; 100) return false;" line632="" line633="        const total = red + green + blue;" line634="        if (total === 0) return false;" line635="" line636="        const redRatio = red / total;" line637="        const greenRatio = green / total;" line638="        const blueRatio = blue / total;" line639="" line640="        const thresholdRatio = threshold / 255;" line641="" line642="        switch (color) {" line643="            case DetectedColor.Red:" line644="                return redRatio &gt; greenRatio + thresholdRatio &amp;&amp;" line645="                    redRatio &gt; blueRatio + thresholdRatio &amp;&amp;" line646="                    redRatio &gt; 0.4;" line647="            case DetectedColor.Green:" line648="                return greenRatio &gt; redRatio + thresholdRatio &amp;&amp;" line649="                    greenRatio &gt; blueRatio + thresholdRatio &amp;&amp;" line650="                    greenRatio &gt; 0.4;" line651="            case DetectedColor.Blue:" line652="                return blueRatio &gt; redRatio + thresholdRatio &amp;&amp;" line653="                    blueRatio &gt; greenRatio + thresholdRatio * 0.8 &amp;&amp;" line654="                    blueRatio &gt; 0.35;" line655="            case DetectedColor.Yellow:" line656="                return redRatio &gt; blueRatio + thresholdRatio &amp;&amp;" line657="                    greenRatio &gt; blueRatio + thresholdRatio &amp;&amp;" line658="                    Math.abs(redRatio - greenRatio) &lt; 0.1 &amp;&amp;" line659="                    redRatio + greenRatio &gt; 0.6;" line660="            default:" line661="                return false;" line662="        }" line663="    }" line664="" line665="    //% blockId=aiponybot_color_sensor_is_in_range" line666="    //% block=&quot;R: %minR ~ %maxR, G: %minG ~ %maxG, B: %minB ~ %maxB&quot;" line667="    //% minR.min=0 minR.max=255 minR.defl=0" line668="    //% maxR.min=0 maxR.max=255 maxR.defl=255" line669="    //% minG.min=0 minG.max=255 minG.defl=0" line670="    //% maxG.min=0 maxG.max=255 maxG.defl=255" line671="    //% minB.min=0 minB.max=255 minB.defl=0" line672="    //% maxB.min=0 maxB.max=255 maxB.defl=255" line673="    //% group=&quot;색상 감지 센서&quot;" line674="    //% inlineInputMode=inline" line675="    export function isColorInRange(minR: number, maxR: number, minG: number, maxG: number, minB: number, maxB: number): boolean {" line676="        const rgb2 = colorSensor.rgb();" line677="        const red2 = rgb2[0];" line678="        const green2 = rgb2[1];" line679="        const blue2 = rgb2[2];" line680="" line681="        return red2 &gt; minR &amp;&amp; red2 &lt; maxR &amp;&amp;" line682="            green2 &gt; minG &amp;&amp; green2 &lt; maxG &amp;&amp;" line683="            blue2 &gt; minB &amp;&amp; blue2 &lt; maxB;" line684="    }" line685="" line686="    /**" line687=" * ---------------oled display-------------------" line688=" */" line689="    const FONT_5X7 = hex`000000000000005F00000007000700147F147F14242A072A12231308646237495522500005030000001C2241000041221C00082A1C2A0808083E080800503000000808080808006060000020100804023E5149453E00427F400042615149462141454B311814127F1027454545393C4A49493001710905033649494936064949291E003636000000563600000008142241141414141441221408000201510906324979413E7E1111117E7F494949363E414141227F4141221C7F494949417F090901013E414151327F0808087F00417F41002040413F017F081422417F404040407F0204027F7F0408107F3E4141413E7F090909063E4151215E7F09192946464949493101017F01013F4040403F1F2040201F7F2018207F63140814630304780403615149454300007F4141020408102041417F000004020102044040404040000102040020545454787F484444383844444420384444487F3854545418087E090102081454543C7F0804047800447D40002040443D00007F10284400417F40007C041804787C0804047838444444387C14141408081414187C7C080404084854545420043F4440203C4040207C1C2040201C3C4030403C44281028440C5050503C4464544C44000836410000007F000000413608000201020402`;" line690="" line691="    export enum Display {" line692="        //% block=&quot;ON&quot;" line693="        On = 1," line694="        //% block=&quot;OFF&quot;" line695="        Off = 0" line696="    }" line697="" line698="    const MIN_X = 0;" line699="    const MIN_Y = 0;" line700="    const MAX_X = 127;" line701="    const MAX_Y = 63;" line702="" line703="    let i2cAddress = 60;" line704="    let screen = pins.createBuffer(1025);" line705="    let buffer22 = pins.createBuffer(2);" line706="    let buffer32 = pins.createBuffer(3);" line707="    let buffer4 = pins.createBuffer(4);" line708="    let buffer7 = pins.createBuffer(7);" line709="    let buffer13 = pins.createBuffer(13);" line710="    buffer7[0] = 0x40;" line711="    buffer13[0] = 0x40;" line712="    let drawEnabled = 1;" line713="    let cursorX = 0;" line714="    let cursorY = 0;" line715="" line716="    let zoomEnabled = 0;" line717="    let doubleSize = 0;" line718="" line719="    function sendCommand1(data: number) {" line720="        let number = data % 256;" line721="        pins.i2cWriteNumber(i2cAddress, number, NumberFormat.UInt16BE);" line722="    }" line723="" line724="    function sendCommand2(data1: number, data2: number) {" line725="        buffer32[0] = 0;" line726="        buffer32[1] = data1;" line727="        buffer32[2] = data2;" line728="        pins.i2cWriteBuffer(i2cAddress, buffer32);" line729="    }" line730="" line731="    function sendCommand3(data1: number, data2: number, data3: number) {" line732="        buffer4[0] = 0;" line733="        buffer4[1] = data1;" line734="        buffer4[2] = data2;" line735="        buffer4[3] = data3;" line736="        pins.i2cWriteBuffer(i2cAddress, buffer4);" line737="    }" line738="" line739="    function setPosition(column: number = 0, page: number = 0) {" line740="        sendCommand1(0xb0 | page);" line741="        sendCommand1(0x00 | (column % 16));" line742="        sendCommand1(0x10 | (column &gt;&gt; 4));" line743="    }" line744="" line745="    function clearBit(data: number, bit: number): number {" line746="        if (data &amp; (1 &lt;&lt; bit)) data -= (1 &lt;&lt; bit);" line747="        return data;" line748="    }" line749="" line750="    function draw(data: number) {" line751="        if (data &gt; 0) {" line752="            setPosition();" line753="            pins.i2cWriteBuffer(i2cAddress, screen);" line754="        }" line755="    }" line756="" line757="    //% block=&quot;디스플레이 색상 반전 %on&quot;" line758="    //% blockGap=8" line759="    //% group=&quot;디스플레이 제어&quot;" line760="    //% on.shadow=&quot;toggleOnOff&quot;" line761="    //% weight=2" line762="    export function invert(on: boolean = true) {" line763="        let number2 = (on) ? 0xA7 : 0xA6;" line764="        sendCommand1(number2);" line765="    }" line766="" line767="    //% block=&quot;디스플레이 지우기&quot;" line768="    //% blockGap=8" line769="    //% group=&quot;디스플레이 제어&quot;" line770="    //% weight=3" line771="    export function clear() {" line772="        cursorX = cursorY = 0;" line773="        screen.fill(0);" line774="        screen[0] = 0x40;" line775="        draw(1);" line776="    }" line777="" line778="    //% block=&quot;디스플레이 화면 %on&quot;" line779="    //% on.defl=1" line780="    //% blockGap=8" line781="    //% group=&quot;디스플레이 제어&quot;" line782="    //% on.shadow=&quot;toggleOnOff&quot;" line783="    //% weight=1" line784="    export function display(on: boolean) {" line785="        if (on) sendCommand1(0xAF);" line786="        else sendCommand1(0xAE);" line787="    }" line788="" line789="    //% block=&quot;픽셀 출력 - 위치: x %x y %y, 색상: %color&quot;" line790="    //% x.max=127 x.min=0 x.defl=0" line791="    //% y.max=63 y.min=0 y.defl=0" line792="    //% color.max=1 color.min=0 color.defl=1" line793="    //% blockGap=8 inlineInputMode=inline" line794="    //% group=&quot;디스플레이 제어(도형)&quot;" line795="    //% weight=4" line796="    export function pixel(x: number, y: number, color: number = 1) {" line797="        let page = y &gt;&gt; 3;" line798="        let shiftPage = y % 8;" line799="        let index2 = x + page * 128 + 1;" line800="        let byte = (color) ? (screen[index2] | (1 &lt;&lt; shiftPage)) : clearBit(screen[index2], shiftPage);" line801="        screen[index2] = byte;" line802="    }" line803="" line804="    function drawChar(character: string, column: number, row: number, color: number = 1) {" line805="        let position = (Math.min(127, Math.max(character.charCodeAt(0), 32)) - 32) * 5;" line806="        let margin = 0;" line807="        let index3 = column + row * 128 + 1;" line808="" line809="        if (doubleSize) {" line810="            for (let i = 0; i &lt; 5; i++) {" line811="                let line = 0;" line812="                for (let j = 0; j &lt; 8; j++) {" line813="                    if (color &gt; 0 ? FONT_5X7[position + i] &amp; (1 &lt;&lt; j) : !(FONT_5X7[position + i] &amp; (1 &lt;&lt; j))) {" line814="                        pixel(column + margin, row * 8 + line);" line815="                        pixel(column + margin, row * 8 + line + 1);" line816="                        pixel(column + margin + 1, row * 8 + line);" line817="                        pixel(column + margin + 1, row * 8 + line + 1);" line818="                    }" line819="                    line += 2;" line820="                }" line821="                margin += 2;" line822="            }" line823="            let line2 = 0;" line824="            for (let k = 0; k &lt; 8; k++) {" line825="                if (color == 0) {" line826="                    pixel(column + 10, row * 8 + line2);" line827="                    pixel(column + 10, row * 8 + line2 + 1);" line828="                    pixel(column + 11, row * 8 + line2);" line829="                    pixel(column + 11, row * 8 + line2 + 1);" line830="                }" line831="                line2 += 2;" line832="            }" line833="        } else {" line834="            let l = 0;" line835="            for (let m = 0; m &lt; 5; m++) {" line836="                screen[index3 + m] = (color &gt; 0) ? FONT_5X7[position + m] : FONT_5X7[position + m] ^ 0xFF;" line837="                if (zoomEnabled) {" line838="                    buffer13[l + 1] = screen[index3 + m];" line839="                    buffer13[l + 2] = screen[index3 + m];" line840="                } else {" line841="                    buffer7[m + 1] = screen[index3 + m];" line842="                }" line843="                l += 2;" line844="            }" line845="            screen[index3 + 5] = (color &gt; 0) ? 0 : 0xFF;" line846="            if (zoomEnabled) {" line847="                buffer13[12] = screen[index3 + 5];" line848="            } else {" line849="                buffer7[6] = screen[index3 + 5];" line850="            }" line851="            setPosition(column, row);" line852="            if (zoomEnabled) {" line853="                pins.i2cWriteBuffer(i2cAddress, buffer13);" line854="            } else {" line855="                pins.i2cWriteBuffer(i2cAddress, buffer7);" line856="            }" line857="        }" line858="    }" line859="" line860="    //% block=&quot;문장 출력 - 내용: %text, 위치: %column열 %row행, 색상: %color&quot;" line861="    //% text.defl='AI ponybot'" line862="    //% column.max=120 column.min=0 column.defl=0" line863="    //% row.max=7 row.min=0 row.defl=0" line864="    //% color.max=1 color.min=0 color.defl=1" line865="    //% blockGap=8 inlineInputMode=inline" line866="    //% group=&quot;디스플레이 제어(데이터)&quot;" line867="    //% weight=1" line868="    export function showString(text: string, column: number, row: number, color: number = 1) {" line869="        let steps = doubleSize ? 12 : 6;" line870="        for (let n = 0; n &lt; text.length; n++) {" line871="            drawChar(text.charAt(n), column, row, color);" line872="            column += steps;" line873="        }" line874="        if (doubleSize) draw(1);" line875="    }" line876="" line877="    //% block=&quot;숫자 출력 - 내용: %number, 위치: %column열 %row행, 색상: %color&quot;" line878="    //% number.defl=777" line879="    //% column.max=120 column.min=0 column.defl=0" line880="    //% row.max=7 row.min=0 row.defl=0" line881="    //% color.max=1 color.min=0 color.defl=1" line882="    //% blockGap=8 inlineInputMode=inline" line883="    //% group=&quot;디스플레이 제어(데이터)&quot;" line884="    //% weight=3" line885="    export function showNumber(number: number, column: number, row: number, color: number = 1) {" line886="        showString(number.toString(), column, row, color);" line887="    }" line888="" line889="    function scroll() {" line890="        cursorX = 0;" line891="        cursorY += doubleSize ? 2 : 1;" line892="        if (cursorY &gt; 7) {" line893="            cursorY = 7;" line894="            screen.shift(128);" line895="            screen[0] = 0x40;" line896="            draw(1);" line897="        }" line898="    }" line899="" line900="    //% block=&quot;문장 출력 - 내용: %text, 줄바꿈: %newline&quot;" line901="    //% text.defl=&quot;AI ponybot&quot;" line902="    //% newline.defl=true" line903="    //% blockGap=8 inlineInputMode=inline" line904="    //% group=&quot;디스플레이 제어(데이터)&quot;" line905="    //% weight=2" line906="    export function printString(text: string, newline: boolean = true) {" line907="        let steps2 = doubleSize ? 12 : 6;" line908="        for (let o = 0; o &lt; text.length; o++) {" line909="            drawChar(text.charAt(o), cursorX, cursorY, 1);" line910="            cursorX += steps2;" line911="            if (cursorX &gt; 120) scroll();" line912="        }" line913="        if (newline) scroll();" line914="        if (doubleSize) draw(1);" line915="    }" line916="" line917="    //% block=&quot;숫자 출력 - 내용: %number, 줄바꿈: %newline&quot;" line918="    //% number.defl=&quot;777&quot;" line919="    //% newline.defl=true" line920="    //% weight=86 blockGap=8 inlineInputMode=inline" line921="    //% group=&quot;디스플레이 제어(데이터)&quot;" line922="    //% weight=4" line923="    export function printNumber(number: number, newline: boolean = true) {" line924="        printString(number.toString(), newline);" line925="    }" line926="" line927="    //% block=&quot;수평선 출력 - 위치: x %x y %y, 길이: %length, 색상: %color&quot;" line928="    //% x.max=127 x.min=0 x.defl=0" line929="    //% y.max=63 y.min=0 y.defl=0" line930="    //% length.max=128 length.min=1 length.defl=16" line931="    //% color.max=1 color.min=0 color.defl=1" line932="    //% blockGap=8 inlineInputMode=inline" line933="    //% group=&quot;디스플레이 제어(도형)&quot;" line934="    //% weight=2" line935="    export function horizontalLine(x: number, y: number, length: number, color: number = 1) {" line936="        let savedDraw = drawEnabled;" line937="        if ((y &lt; MIN_Y) || (y &gt; MAX_Y)) return;" line938="        drawEnabled = 0;" line939="        for (let p = x; p &lt; (x + length); p++)" line940="            if ((p &gt;= MIN_X) &amp;&amp; (p &lt;= MAX_X))" line941="                pixel(p, y, color);" line942="        drawEnabled = savedDraw;" line943="        draw(drawEnabled);" line944="    }" line945="" line946="    //% block=&quot;수직선 출력 - 위치: x %x y %y, 길이: %length, 색상: %color&quot;" line947="    //% x.max=127 x.min=0 x.defl=0" line948="    //% y.max=63 y.min=0 y.defl=0" line949="    //% length.max=128 length.min=1 length.defl=16" line950="    //% color.max=1 color.min=0 color.defl=1" line951="    //% blockGap=8 inlineInputMode=inline" line952="    //% group=&quot;디스플레이 제어(도형)&quot;" line953="    //% weight=1" line954="    export function verticalLine(x: number, y: number, length: number, color: number = 1) {" line955="        let savedDraw2 = drawEnabled;" line956="        drawEnabled = 0;" line957="        if ((x &lt; MIN_X) || (x &gt; MAX_X)) return;" line958="        for (let q = y; q &lt; (y + length); q++)" line959="            if ((q &gt;= MIN_Y) &amp;&amp; (q &lt;= MAX_Y))" line960="                pixel(x, q, color);" line961="        drawEnabled = savedDraw2;" line962="        draw(drawEnabled);" line963="    }" line964="" line965="    //% block=&quot;사각형 출력 - x1 %x1 y1 %y1 x2 %x2 y2 %y2, 색상: %color&quot;" line966="    //% color.defl=1" line967="    //% blockGap=8 inlineInputMode=inline" line968="    //% group=&quot;디스플레이 제어(도형)&quot;" line969="    //% weight=3" line970="    export function rectangle(x1: number, y1: number, x2: number, y2: number, color: number = 1) {" line971="        if (x1 &gt; x2) x1 = [x2, x2 = x1][0];" line972="        if (y1 &gt; y2) y1 = [y2, y2 = y1][0];" line973="        drawEnabled = 0;" line974="        horizontalLine(x1, y1, x2 - x1 + 1, color);" line975="        horizontalLine(x1, y2, x2 - x1 + 1, color);" line976="        verticalLine(x1, y1, y2 - y1 + 1, color);" line977="        verticalLine(x2, y1, y2 - y1 + 1, color);" line978="        drawEnabled = 1;" line979="        draw(1);" line980="    }" line981="" line982="    function initialize() {" line983="        sendCommand1(0xAE);       // SSD1306_DISPLAYOFF" line984="        sendCommand1(0xA4);       // SSD1306_DISPLAYALLON_RESUME" line985="        sendCommand2(0xD5, 0xF0); // SSD1306_SETDISPLAYCLOCKDIV" line986="        sendCommand2(0xA8, 0x3F); // SSD1306_SETMULTIPLEX" line987="        sendCommand2(0xD3, 0x00); // SSD1306_SETDISPLAYOFFSET" line988="        sendCommand1(0 | 0x0);    // line #SSD1306_SETSTARTLINE" line989="        sendCommand2(0x8D, 0x14); // SSD1306_CHARGEPUMP" line990="        sendCommand2(0x20, 0x00); // SSD1306_MEMORYMODE" line991="        sendCommand3(0x21, 0, 127); // SSD1306_COLUMNADDR" line992="        sendCommand3(0x22, 0, 63);  // SSD1306_PAGEADDR" line993="        sendCommand1(0xa0 | 0x1); // SSD1306_SEGREMAP" line994="        sendCommand1(0xc8);       // SSD1306_COMSCANDEC" line995="        sendCommand2(0xDA, 0x12); // SSD1306_SETCOMPINS" line996="        sendCommand2(0x81, 0xCF); // SSD1306_SETCONTRAST" line997="        sendCommand2(0xd9, 0xF1); // SSD1306_SETPRECHARGE" line998="        sendCommand2(0xDB, 0x40); // SSD1306_SETVCOMDETECT" line999="        sendCommand1(0xA6);       // SSD1306_NORMALDISPLAY" line1000="        sendCommand2(0xD6, 0);    // zoom off" line1001="        sendCommand1(0xAF);       // SSD1306_DISPLAYON" line1002="        clear();" line1003="    }" line1004="" line1005="    /**" line1006="         * ==========================================" line1007="         * Boundary X - AI Data Parsing Extension (Updated)" line1008="         * ==========================================" line1009="         */" line1010="" line1011="    // 1. Hand Pose (RC Car) Enums" line1012="    export enum HandType {" line1013="        //% block=&quot;왼손(L)&quot;" line1014="        Left," line1015="        //% block=&quot;오른손(R)&quot;" line1016="        Right" line1017="    }" line1018="" line1019="    export enum HandAttribute {" line1020="        //% block=&quot;방향(1:전진, -1:후진)&quot;" line1021="        Direction," line1022="        //% block=&quot;속도(0~255)&quot;" line1023="        Speed" line1024="    }" line1025="" line1026="    // 2. Face Mesh Enums (Index Mapping)" line1027="    export enum FaceAttribute {" line1028="        //% block=&quot;X 좌표(0~99)&quot;" line1029="        X = 0," line1030="        //% block=&quot;Y 좌표(0~99)&quot;" line1031="        Y = 2," line1032="        //% block=&quot;거리 Z(0~99)&quot;" line1033="        Z = 4," line1034="        //% block=&quot;고개 회전(Yaw)&quot;" line1035="        Yaw = 6," line1036="        //% block=&quot;고개 숙임(Pitch)&quot;" line1037="        Pitch = 8," line1038="        //% block=&quot;입 벌림(Mouth)&quot;" line1039="        Mouth = 10," line1040="        //% block=&quot;왼쪽 눈(L-Eye)&quot;" line1041="        LeftEye = 12," line1042="        //% block=&quot;오른쪽 눈(R-Eye)&quot;" line1043="        RightEye = 14," line1044="        //% block=&quot;고개 기울기(Roll)&quot;" line1045="        Roll = 16," line1046="        //% block=&quot;미소(Smile)&quot;" line1047="        Smile = 17," line1048="        //% block=&quot;인식 여부(Vis)&quot;" line1049="        Vis = 18" line1050="    }" line1051="" line1052="    // 3. Color / Object Data Enums" line1053="    export enum AIColorKey {" line1054="        //% block=&quot;클래스 ID (I)&quot;" line1055="        ID," line1056="        //% block=&quot;빨간색 (R)&quot;" line1057="        Red," line1058="        //% block=&quot;초록색 (G)&quot;" line1059="        Green," line1060="        //% block=&quot;파란색 (B)&quot;" line1061="        Blue" line1062="    }" line1063="" line1064="    export enum UARTDataType {" line1065="        //% block=&quot;X 좌표&quot;" line1066="        X," line1067="        //% block=&quot;Y 좌표&quot;" line1068="        Y," line1069="        //% block=&quot;너비&quot;" line1070="        W," line1071="        //% block=&quot;높이&quot;" line1072="        H," line1073="        //% block=&quot;객체 수&quot;" line1074="        D" line1075="    }" line1076="" line1077="    // ---------------------------------------------------" line1078="    // [Block 1] Hand Pose Parsing (RC Controller)" line1079="    // Format: L{Dir}{Speed}R{Dir}{Speed} (e.g., LF255RB200)" line1080="    // ---------------------------------------------------" line1081="    //% group=&quot;AI 데이터 활용&quot;" line1082="    //% block=&quot;[AI 모션인식] 수신값 %data 에서 %hand 의 %attr 추출&quot;" line1083="    //% weight=90" line1084="    export function parseHandPose(data: string, hand: HandType, attr: HandAttribute): number {" line1085="        if (!data || data.length &lt; 5) return 0;" line1086="" line1087="        // 1. Find Start Index (L or R)" line1088="        let startIndex = (hand === HandType.Left) ? data.indexOf(&quot;L&quot;) : data.indexOf(&quot;R&quot;);" line1089="        if (startIndex === -1) return 0;" line1090="" line1091="        // 2. Parse Direction or Speed" line1092="        if (attr === HandAttribute.Direction) {" line1093="            // L 바로 다음 글자가 방향 (F or B)" line1094="            let dirChar = data.charAt(startIndex + 1);" line1095="            if (dirChar === &quot;F&quot;) return 1;       // Forward -&gt; 1" line1096="            if (dirChar === &quot;B&quot;) return -1;      // Backward -&gt; -1" line1097="            return 0;" line1098="        } else {" line1099="            // L + 2번째 글자부터 3글자가 속도 (000~255)" line1100="            let speedStr = data.substr(startIndex + 2, 3);" line1101="            let speed = parseInt(speedStr);" line1102="            return isNaN(speed) ? 0 : speed;" line1103="        }" line1104="    }" line1105="" line1106="    // ---------------------------------------------------" line1107="    // [Block 2] Face Mesh Parsing" line1108="    // Format: 19 digits fixed (e.g., 5050605050009999501)" line1109="    // ---------------------------------------------------" line1110="    //% group=&quot;AI 데이터 활용&quot;" line1111="    //% block=&quot;[AI 얼굴인식] 수신값 %data 에서 %attr 추출&quot;" line1112="    //% weight=80" line1113="    export function parseFaceMesh(data: string, attr: FaceAttribute): number {" line1114="        // 데이터 길이 검증 (최소 19자리)" line1115="        if (!data || data.length &lt; 19) return -1;" line1116="" line1117="        // 마지막 3개 속성(Roll, Smile, Vis)은 1자리, 나머지는 2자리" line1118="        let length = (attr &gt;= 16) ? 1 : 2;" line1119="" line1120="        // 해당 인덱스에서 잘라내기" line1121="        let valueStr = data.substr(attr, length);" line1122="        let val = parseInt(valueStr);" line1123="" line1124="        return isNaN(val) ? -1 : val;" line1125="    }" line1126="" line1127="    // ---------------------------------------------------" line1128="    // [Block 3] Color Recognition Parsing" line1129="    // Format: I{ID}R{Red}G{Green}B{Blue}" line1130="    // ---------------------------------------------------" line1131="    //% group=&quot;AI 데이터 활용&quot;" line1132="    //% block=&quot;[AI 컬러인식] 수신값 %data 에서 %key 값 추출&quot;" line1133="    //% weight=70" line1134="    export function parseColorExtended(data: string, key: AIColorKey): number {" line1135="        if (data === &quot;stop&quot;) return -1;" line1136="" line1137="        let charKey = &quot;&quot;;" line1138="        switch (key) {" line1139="            case AIColorKey.ID: charKey = &quot;I&quot;; break;" line1140="            case AIColorKey.Red: charKey = &quot;R&quot;; break;" line1141="            case AIColorKey.Green: charKey = &quot;G&quot;; break;" line1142="            case AIColorKey.Blue: charKey = &quot;B&quot;; break;" line1143="        }" line1144="" line1145="        let val2 = getValue(data, charKey);" line1146="        return val2 === &quot;&quot; ? -1 : parseInt(val2);" line1147="    }" line1148="" line1149="    // ---------------------------------------------------" line1150="    // [Block 4] Object Recognition Parsing" line1151="    // Format: x{X}y{Y}w{W}h{H}d{Count}" line1152="    // ---------------------------------------------------" line1153="    //% group=&quot;AI 데이터 활용&quot;" line1154="    //% block=&quot;[AI 사물인식] 수신값 %data 에서 %type 추출&quot;" line1155="    //% weight=60" line1156="    export function parseObjectData(data: string, type: UARTDataType): number {" line1157="        if (data === &quot;stop&quot; || data === &quot;null&quot;) return -1;" line1158="" line1159="        let charKey2 = &quot;&quot;;" line1160="        switch (type) {" line1161="            case UARTDataType.X: charKey2 = &quot;x&quot;; break;" line1162="            case UARTDataType.Y: charKey2 = &quot;y&quot;; break;" line1163="            case UARTDataType.W: charKey2 = &quot;w&quot;; break;" line1164="            case UARTDataType.H: charKey2 = &quot;h&quot;; break;" line1165="            case UARTDataType.D: charKey2 = &quot;d&quot;; break;" line1166="        }" line1167="" line1168="        let val3 = getValue(data, charKey2);" line1169="        return val3 === &quot;&quot; ? -1 : parseInt(val3);" line1170="    }" line1171="" line1172="    /**" line1173="     * [Core Helper] 문자열 파싱 엔진" line1174="     * 키(Key)와 다음 키(Next Key) 사이의 값을 추출합니다." line1175="     */" line1176="    function getValue(data: string, key: string): string {" line1177="        let start = data.indexOf(key);" line1178="        if (start &lt; 0) return &quot;&quot;;" line1179="" line1180="        let end = data.length;" line1181="        // [중요] 구분자로 인식할 모든 키를 여기에 등록해야 함" line1182="        // 기존 코드에는 I, L, R 등이 빠져 있었음" line1183="        const keys = [&quot;x&quot;, &quot;y&quot;, &quot;w&quot;, &quot;h&quot;, &quot;d&quot;, &quot;R&quot;, &quot;G&quot;, &quot;B&quot;, &quot;I&quot;, &quot;L&quot;, &quot;R&quot;, &quot;\n&quot;];" line1184="" line1185="        for (let r of keys) {" line1186="            if (r != key) {" line1187="                // 현재 키 뒤에 등장하는 가장 가까운 구분자 찾기" line1188="                const s = data.indexOf(r, start + 1);" line1189="                if (s &gt;= 0 &amp;&amp; s &lt; end) {" line1190="                    end = s;" line1191="                }" line1192="            }" line1193="        }" line1194="        return data.substr(start + 1, end - start - 1);" line1195="    }" line1196="" line1197="    export namespace smbus {" line1198="        export function writeByte(address: number, register: number, value: number): void {" line1199="            let temp = pins.createBuffer(2);" line1200="            temp[0] = register;" line1201="            temp[1] = value;" line1202="            pins.i2cWriteBuffer(address, temp, false);" line1203="        }" line1204="        export function writeBuffer(address: number, register: number, value: Buffer): void {" line1205="            let temp2 = pins.createBuffer(value.length + 1);" line1206="            temp2[0] = register;" line1207="            for (let index4 = 0; index4 &lt; value.length; index4++) {" line1208="                temp2[index4 + 1] = value[index4];" line1209="            }" line1210="            pins.i2cWriteBuffer(address, temp2, false);" line1211="        }" line1212="        export function readBuffer(address: number, register: number, length: number): Buffer {" line1213="            let temp3 = pins.createBuffer(1);" line1214="            temp3[0] = register;" line1215="            pins.i2cWriteBuffer(address, temp3, false);" line1216="            return pins.i2cReadBuffer(address, length, false);" line1217="        }" line1218="        export function readNumber(address: number, register: number, format: NumberFormat = NumberFormat.UInt8LE): number {" line1219="            let temp4 = pins.createBuffer(1);" line1220="            temp4[0] = register;" line1221="            pins.i2cWriteBuffer(address, temp4, false);" line1222="            return pins.i2cReadNumber(address, format, false);" line1223="        }" line1224="        export function unpack(format: string, buffer: Buffer): number[] {" line1225="            let littleEndian: boolean = true;" line1226="            let offset: number = 0;" line1227="            let result3: number[] = [];" line1228="            let numberFormat: NumberFormat = 0;" line1229="            for (let charIndex = 0; charIndex &lt; format.length; charIndex++) {" line1230="                switch (format.charAt(charIndex)) {" line1231="                    case '&lt;':" line1232="                        littleEndian = true;" line1233="                        continue;" line1234="                    case '&gt;':" line1235="                        littleEndian = false;" line1236="                        continue;" line1237="                    case 'c':" line1238="                    case 'B':" line1239="                        numberFormat = littleEndian ? NumberFormat.UInt8LE : NumberFormat.UInt8BE; break;" line1240="                    case 'b':" line1241="                        numberFormat = littleEndian ? NumberFormat.Int8LE : NumberFormat.Int8BE; break;" line1242="                    case 'H':" line1243="                        numberFormat = littleEndian ? NumberFormat.UInt16LE : NumberFormat.UInt16BE; break;" line1244="                    case 'h':" line1245="                        numberFormat = littleEndian ? NumberFormat.Int16LE : NumberFormat.Int16BE; break;" line1246="                }" line1247="                result3.push(buffer.getNumber(numberFormat, offset));" line1248="                offset += pins.sizeOf(numberFormat);" line1249="            }" line1250="            return result3;" line1251="        }" line1252="    }" line1253="" line1254="    initialize();" line1255="}" numlines="1256"></mutation></block></statement></block><block type="aiPonybot_parseHandPose" id="=)X79.Jp5LzT;BP..Hmo" disabled-reasons="pxt_automatic_disabled" x="5" y="592"><field name="hand">aiPonybot.HandType.Left</field><field name="attr">aiPonybot.HandAttribute.Direction</field><value name="data"><shadow type="text" id="pBKl[.*/YzjdI$75*1fP" disabled-reasons="pxt_automatic_disabled"><field name="TEXT"></field></shadow></value></block></xml>